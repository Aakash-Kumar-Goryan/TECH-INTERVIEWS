# Generics & Type System

Generics questions test deep language understanding. Master type erasure and wildcards.

## 1. Why Generics?

Before Java 5:

```java
List list = new ArrayList();
list.add("hello");
list.add(123);  // Allowed! No type safety.
String s = (String) list.get(1);  // Runtime ClassCastException!
```

With Generics:

```java
List<String> list = new ArrayList<>();
list.add("hello");
list.add(123);  // Compile error! Type safety.
String s = list.get(0);  // No cast needed.
```

**Benefits**:

- Compile-time type safety
- Elimination of casts
- Enable generic algorithms (once, for all types)

---

## 2. Generic Classes and Methods

### Generic Class

```java
public class Box<T> {
    private T content;
    
    public void set(T content) {
        this.content = content;
    }
    
    public T get() {
        return content;
    }
}

Box<String> stringBox = new Box<>();
stringBox.set("hello");
String s = stringBox.get();
```

### Multiple Type Parameters

```java
public class Pair<K, V> {
    private K key;
    private V value;
    
    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
}

Pair<String, Integer> pair = new Pair<>("age", 25);
```

### Generic Methods

```java
public class Util {
    public static <T> T getFirst(List<T> list) {
        return list.isEmpty() ? null : list.get(0);
    }
    
    public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
        return p1.getKey().equals(p2.getKey());
    }
}

// Type inference
String first = Util.getFirst(List.of("a", "b"));

// Explicit type (rarely needed)
String first = Util.<String>getFirst(List.of("a", "b"));
```

---

## 3. Type Erasure

**Java generics are compile-time only.** At runtime, type information is erased.

### What Happens

| Compile Time | Runtime |
|--------------|---------|
| `List<String>` | `List` |
| `Box<Integer>` | `Box` |
| `T` | `Object` (or bound) |

### Implications

```java
// Cannot do at runtime:
if (obj instanceof List<String>) { }  // Error: type erased
new T();                              // Error: no type info
new T[];                              // Error: cannot create generic array

// These are the SAME class at runtime:
List<String> strList = new ArrayList<>();
List<Integer> intList = new ArrayList<>();
strList.getClass() == intList.getClass();  // true!
```

### Bridge Methods

Compiler generates bridge methods to preserve polymorphism:

```java
public class StringBox extends Box<String> {
    @Override
    public void set(String content) { }  // Actual method
    
    // Bridge method generated by compiler:
    public void set(Object content) {    // Overrides Box.set(Object)
        set((String) content);           // Delegates to typed version
    }
}
```

---

## 4. Bounded Type Parameters

### Upper Bound (`extends`)

```java
// T must be Number or subclass
public class Statistics<T extends Number> {
    private T[] numbers;
    
    public double average() {
        double sum = 0;
        for (T n : numbers) {
            sum += n.doubleValue();  // Can call Number methods
        }
        return sum / numbers.length;
    }
}

Statistics<Integer> intStats = new Statistics<>();  // OK
Statistics<String> strStats = new Statistics<>();   // Error!
```

### Multiple Bounds

```java
// T must extend Comparable AND Serializable
public <T extends Comparable<T> & Serializable> T max(T a, T b) {
    return a.compareTo(b) > 0 ? a : b;
}
```

**Note**: Class bound must come first, then interfaces.

---

## 5. Wildcards (Critical for Interviews)

### Unbounded Wildcard (`<?>`)

```java
public void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}

printList(List.of(1, 2, 3));
printList(List.of("a", "b"));
```

**Cannot add** (except null):

```java
List<?> list = new ArrayList<String>();
list.add("hello");  // Error! Don't know actual type.
list.add(null);     // OK (null is valid for any type)
```

### Upper Bounded (`<? extends T>`)

"Producer Extends" - Read from, don't write to.

```java
public double sumAll(List<? extends Number> list) {
    double sum = 0;
    for (Number n : list) {  // Can read as Number
        sum += n.doubleValue();
    }
    return sum;
}

sumAll(List.of(1, 2, 3));           // List<Integer>
sumAll(List.of(1.5, 2.5));          // List<Double>
```

**Cannot add**:

```java
List<? extends Number> list = new ArrayList<Integer>();
list.add(42);  // Error! Might be List<Double>
```

### Lower Bounded (`<? super T>`)

"Consumer Super" - Write to, read as Object.

```java
public void addNumbers(List<? super Integer> list) {
    list.add(1);   // Can add Integer
    list.add(2);
    list.add(3);
}

addNumbers(new ArrayList<Integer>());
addNumbers(new ArrayList<Number>());
addNumbers(new ArrayList<Object>());
```

**Read returns Object**:

```java
List<? super Integer> list = new ArrayList<Number>();
Object obj = list.get(0);  // Only Object, not Integer
```

---

## 6. PECS Principle

> **P**roducer **E**xtends, **C**onsumer **S**uper

| Role | Wildcard | Operations |
|------|----------|------------|
| Producer (read from) | `<? extends T>` | Get items |
| Consumer (write to) | `<? super T>` | Add items |
| Both | `<T>` | Get and add |

### Example: Collections.copy()

```java
public static <T> void copy(
    List<? super T> dest,     // Consumer: writes to
    List<? extends T> src     // Producer: reads from
) {
    for (T item : src) {
        dest.add(item);
    }
}

List<Number> numbers = new ArrayList<>();
List<Integer> integers = List.of(1, 2, 3);
Collections.copy(numbers, integers);  // Copy integers to numbers
```

---

## 7. Covariance vs Contravariance

### Arrays are Covariant

```java
Number[] numbers = new Integer[10];  // OK (covariant)
numbers[0] = 3.14;  // Runtime ArrayStoreException!
```

### Generics are Invariant (by default)

```java
List<Number> numbers = new ArrayList<Integer>();  // Error!
// Even though Integer extends Number
```

### Wildcards enable variance

| Type | Variance | Wildcard |
|------|----------|----------|
| `List<? extends Number>` | Covariant | Read-only |
| `List<? super Integer>` | Contravariant | Write-only |
| `List<Number>` | Invariant | Read + Write |

---

## 8. Generic Gotchas

### Cannot Create Generic Arrays

```java
T[] array = new T[10];  // Error!

// Workaround
@SuppressWarnings("unchecked")
T[] array = (T[]) new Object[10];
```

### Cannot Use Primitives

```java
List<int> list;  // Error!
List<Integer> list;  // Use wrapper class
```

### Static Context

Static members cannot use class type parameters:

```java
public class Box<T> {
    private static T value;  // Error! T is instance-level
    
    public static <T> T getValue() { }  // OK: method declares own T
}
```

### Type Inference Diamond

```java
// Java 7+: Diamond operator
List<String> list = new ArrayList<>();  // Infers <String>

// Lambda type inference
Function<String, Integer> func = s -> s.length();  // Infers types
```

---

## 9. Reflection and Generics

Type information preserved in some cases:

```java
// Get generic type of field
Field field = MyClass.class.getDeclaredField("list");
ParameterizedType type = (ParameterizedType) field.getGenericType();
Type[] typeArgs = type.getActualTypeArguments();
// typeArgs[0] is String.class for List<String>
```

### TypeToken Pattern (Guava/Gson)

```java
// Capture generic type at compile time
TypeToken<List<String>> token = new TypeToken<List<String>>() {};
Type type = token.getType();  // Preserves List<String>
```

---

## 10. Interview Questions

**Q: Why can't you do `new T()`?**

Type erasure. At runtime, T becomes Object. JVM doesn't know what constructor to call.

**Workaround**:

```java
public <T> T create(Class<T> clazz) throws Exception {
    return clazz.getDeclaredConstructor().newInstance();
}
```

**Q: Difference between `<?>` and `<? extends Object>`?**

Semantically same. Both accept any type. `<?>` is shorthand.

**Q: Why is `List<Object>` not the same as `List<?>`?**

```java
List<Object> objList = new ArrayList<>();
objList.add("string");  // OK: can add any Object

List<?> unknownList = new ArrayList<String>();
unknownList.add("string");  // Error! Type unknown
```

**Q: What is a raw type?**

Using generic class without type parameter:

```java
List list = new ArrayList();  // Raw type (avoid!)
List<String> list = new ArrayList<>();  // Parameterized type
```
