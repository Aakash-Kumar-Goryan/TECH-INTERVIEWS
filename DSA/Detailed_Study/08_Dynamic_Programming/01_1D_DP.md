# Dynamic Programming - 1D Patterns

> **Trigger**: Optimal substructure, overlapping subproblems, "min/max ways to reach", "count possibilities"

---

## Framework

1. **Define state**: What info needed to solve subproblem?
2. **Recurrence**: How to build from smaller subproblems?
3. **Base case**: Smallest subproblem answer
4. **Direction**: Bottom-up or top-down?

---

## Template: Bottom-Up

```cpp
int solve(vector<int>& nums) {
    int n = nums.size();
    vector<int> dp(n, 0);
    
    // Base case
    dp[0] = /* initial value */;
    
    // Fill DP table
    for (int i = 1; i < n; i++) {
        dp[i] = /* recurrence using dp[0..i-1] */;
    }
    
    return dp[n-1];
}
```

---

## Example 1: Climbing Stairs

**LeetCode 70** | O(n) time, O(1) space

```cpp
int climbStairs(int n) {
    if (n <= 2) return n;
    
    int prev2 = 1, prev1 = 2;
    for (int i = 3; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
// dp[i] = dp[i-1] + dp[i-2]
```

---

## Example 2: House Robber

**LeetCode 198** | O(n) time, O(1) space

```cpp
int rob(vector<int>& nums) {
    if (nums.empty()) return 0;
    
    int prev2 = 0, prev1 = 0;
    for (int num : nums) {
        int curr = max(prev1, prev2 + num);
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
// dp[i] = max(dp[i-1], dp[i-2] + nums[i])
```

---

## Example 3: Coin Change

**LeetCode 322** | O(n×amount) time

```cpp
int coinChange(vector<int>& coins, int amount) {
    vector<int> dp(amount + 1, amount + 1);
    dp[0] = 0;
    
    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (coin <= i) {
                dp[i] = min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    return dp[amount] > amount ? -1 : dp[amount];
}
// dp[i] = min coins to make amount i
```

---

## Example 4: Longest Increasing Subsequence

**LeetCode 300** | O(n log n) with binary search

```cpp
int lengthOfLIS(vector<int>& nums) {
    vector<int> dp; // dp[i] = smallest tail for LIS of length i+1
    
    for (int num : nums) {
        auto it = lower_bound(dp.begin(), dp.end(), num);
        if (it == dp.end()) dp.push_back(num);
        else *it = num;
    }
    return dp.size();
}
```

**O(n²) version:**

```cpp
int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    vector<int> dp(n, 1);
    
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }
    return *max_element(dp.begin(), dp.end());
}
```

---

## Space Optimization

| Pattern | Optimization |
|---------|--------------|
| dp[i] depends on dp[i-1], dp[i-2] | Use 2 variables |
| dp[i] depends on dp[i-1] only | Use 1 variable |
| 2D: dp[i][j] depends on previous row | Keep 2 rows |

---

## Practice Problems

| Problem | Difficulty | Key Insight |
|---------|------------|-------------|
| LC 70 - Climbing Stairs | Easy | Fibonacci pattern |
| LC 198 - House Robber | Medium | Take/skip decision |
| LC 322 - Coin Change | Medium | Unbounded knapsack |
| LC 300 - LIS | Medium | Binary search optimization |
| LC 139 - Word Break | Medium | dp[i] = can form s[0..i-1] |
